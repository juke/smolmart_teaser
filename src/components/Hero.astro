---
interface Props {
  logo: ImageMetadata;
  smol2: ImageMetadata;
  smol3: ImageMetadata;
  smol4: ImageMetadata;
}

import { Image } from 'astro:assets';
import { Banana } from 'lucide-react';
const { logo, smol2, smol3, smol4 } = Astro.props;
---

<div class="flex flex-col items-center gap-8 sm:gap-12 text-center max-w-5xl mx-auto">
  <div class="space-y-6 sm:space-y-10">
    <div class="w-full px-4 sm:px-8 md:px-12">
      <img
        src={logo.src}
        alt="Smolmart Logo"
        class="w-full max-w-[340px] sm:max-w-[500px] md:max-w-[640px] mx-auto animate-logo-intro drop-shadow-logo"
        style="object-fit: contain; height: auto;"
      />
    </div>
    
    <div class="relative px-4 sm:px-8 space-y-8">
      <div class="relative w-full max-w-4xl mx-auto">
        <h2 class="text-4xl sm:text-5xl md:text-6xl font-black tracking-wider relative group animate-title-intro opacity-0">
          <span class="relative block mb-4">
            <span class="animate-gradient bg-gradient-to-r from-[#FFB938] via-[#2EAE4E] via-[#1A7431] via-[#4ECB71] to-[#FFB938] bg-[length:400%_auto] bg-clip-text text-transparent drop-shadow-glow tracking-wide">Meme-Driven</span>
          </span>
          <span class="relative block">
            <span class="animate-gradient bg-gradient-to-r from-[#FFB938] via-[#2EAE4E] via-[#1A7431] via-[#4ECB71] to-[#FFB938] bg-[length:400%_auto] bg-clip-text text-transparent drop-shadow-glow tracking-wide">Art Marketplace</span>
          </span>
        </h2>
      </div>

      <p class="relative text-lg sm:text-xl md:text-2xl font-medium max-w-3xl mx-auto leading-relaxed tracking-wide animate-text-intro opacity-0">
        <span class="relative text-[#FFB938] drop-shadow-sm tracking-wide">Turn your favorite memes into <span class="font-bold tracking-wide">legendary art pieces</span>.</span>
        <br class="hidden sm:block" />
        <span class="relative text-[#4ECB71] tracking-wide">Join our jungle of creators, collect rare <span class="font-bold text-[#2EAE4E] tracking-wide">meme-sterpieces</span>,</span>
        <br class="hidden sm:block" />
        <span class="relative text-[#FFB938] tracking-wide">and stack those sweet, sweet <span class="font-bold animate-pulse-slow inline-flex items-center gap-1 tracking-wide">
          bananas <Banana class="w-6 h-6" />
        </span>.</span>
      </p>
    </div>
  </div>

  <!-- Hidden images for Three.js textures -->
  <div class="hidden">
    <img src={smol2.src} alt="Art Example 1" id="texture1" />
    <img src={smol3.src} alt="Art Example 2" id="texture2" />
    <img src={smol4.src} alt="Art Example 3" id="texture3" />
  </div>

  <!-- Three.js Canvas Container -->
  <div class="relative w-full -mt-12 sm:-mt-20 mb-64 sm:mb-80">
    <div class="absolute left-1/2 -translate-x-1/2" style="width: 150%;">
      <canvas id="art-gallery" class="w-full h-[320px] sm:h-[400px] rounded-xl"></canvas>
    </div>
  </div>

  <div class="mt-8 sm:mt-12 w-full max-w-md px-4 animate-slide-up">
    <form class="flex flex-col sm:flex-row gap-3">
      <input
        type="email"
        placeholder="Enter your email for early access"
        class="flex-1 px-4 sm:px-6 py-3 rounded-lg bg-background/50 border border-primary/20 focus:border-primary/50 outline-none text-sm tracking-wider shadow-sm transition-transform hover:scale-[1.01] focus:scale-[1.01]"
      />
      <button
        type="submit"
        class="px-6 py-3 rounded-lg bg-secondary hover:bg-secondary/90 text-secondary-foreground font-medium tracking-wider transition-transform hover:scale-[1.02] active:scale-[0.98]"
      >
        Join Now
      </button>
    </form>
  </div>
</div>

<style>
  .animate-fade-in {
    opacity: 0;
    animation: fadeIn 0.8s ease-out forwards;
  }

  .animate-slide-up {
    opacity: 0;
    transform: translateY(20px);
    animation: slideUp 0.8s ease-out forwards;
  }

  @keyframes fadeIn {
    to {
      opacity: 1;
    }
  }

  @keyframes slideUp {
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  /* New animations */
  @keyframes pulse-slow {
    0%, 100% { opacity: 0.3; }
    50% { opacity: 0.5; }
  }

  .animate-pulse-slow {
    animation: pulse-slow 6s cubic-bezier(0.4, 0, 0.6, 1) infinite;
  }

  .animate-word-in {
    animation: wordIn 0.8s cubic-bezier(0.34, 1.56, 0.64, 1) both;
  }

  .delay-100 {
    animation-delay: 100ms;
  }

  @keyframes wordIn {
    from {
      opacity: 0;
      transform: translateY(20%);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .animate-gradient {
    animation: gradient 30s linear infinite;
    background-size: 400% auto;
  }

  @keyframes gradient {
    0% { background-position: 0% 50%; }
    100% { background-position: 400% 50%; }
  }

  /* Add glow effect */
  .drop-shadow-glow {
    filter: drop-shadow(0 0 15px rgba(255, 185, 56, 0.3))
           drop-shadow(0 0 50px rgba(46, 174, 78, 0.2));
    text-shadow: 0 0 20px rgba(255, 185, 56, 0.1);
  }

  /* Add slower gradient animation for description */
  .animate-gradient-slow {
    animation: gradient 45s linear infinite;
    background-size: 400% auto;
  }

  /* Add custom drop shadow for the logo */
  .drop-shadow-logo {
    filter: drop-shadow(0 0 20px rgba(255, 185, 56, 0.15))
           drop-shadow(0 0 35px rgba(46, 174, 78, 0.15))
           drop-shadow(0 0 3px rgba(255, 255, 255, 0.3));
  }

  /* Updated and new animations */
  .animate-logo-intro {
    opacity: 0;
    transform: translateY(-20px);
    animation: logoIntro 1s cubic-bezier(0.22, 1, 0.36, 1) forwards;
  }

  .animate-title-intro {
    animation: titleIntro 1s cubic-bezier(0.22, 1, 0.36, 1) forwards;
    animation-delay: 0.3s;
  }

  .animate-text-intro {
    animation: textIntro 1s cubic-bezier(0.22, 1, 0.36, 1) forwards;
    animation-delay: 0.6s;
  }

  @keyframes logoIntro {
    from {
      opacity: 0;
      transform: translateY(-20px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  @keyframes titleIntro {
    from {
      opacity: 0;
      transform: translateY(20px) scale(0.95);
    }
    to {
      opacity: 1;
      transform: translateY(0) scale(1);
    }
  }

  @keyframes textIntro {
    from {
      opacity: 0;
      transform: translateY(20px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }
</style>

<script>
  import * as THREE from 'three';

  function createRoundedRectShape(width: number, height: number, radius: number) {
    const shape = new THREE.Shape();
    
    shape.moveTo(-width/2 + radius, -height/2);
    shape.lineTo(width/2 - radius, -height/2);
    shape.quadraticCurveTo(width/2, -height/2, width/2, -height/2 + radius);
    shape.lineTo(width/2, height/2 - radius);
    shape.quadraticCurveTo(width/2, height/2, width/2 - radius, height/2);
    shape.lineTo(-width/2 + radius, height/2);
    shape.quadraticCurveTo(-width/2, height/2, -width/2, height/2 - radius);
    shape.lineTo(-width/2, -height/2 + radius);
    shape.quadraticCurveTo(-width/2, -height/2, -width/2 + radius, -height/2);

    return shape;
  }

  window.addEventListener('load', () => {
    const canvas = document.getElementById('art-gallery') as HTMLCanvasElement;
    const scene = new THREE.Scene();
    
    // Replace the existing lighting setup with:
    const ambientLight = new THREE.AmbientLight(0xffffff, 1.6);
    scene.add(ambientLight);

    // Replace the directional light with a focused spotlight
    const galleryLight = new THREE.SpotLight(0xffffff, 22.0, 50, Math.PI/3.2, 0.4, 0.5);
    galleryLight.position.set(0, 12, 5);  // Increased Y from 8 to 12
    galleryLight.target.position.set(0, 2, 0);  // Adjusted target Y from 0 to 2 to maintain angle
    galleryLight.castShadow = true;

    // Darker shadows
    galleryLight.shadow.bias = -0.0002;
    galleryLight.shadow.darkness = 1.0;

    scene.add(galleryLight);
    scene.add(galleryLight.target);

    // Brighter fill light
    const fillLight = new THREE.PointLight(0xffffff, 4.0, 30);
    fillLight.position.set(0, 5, 10);
    scene.add(fillLight);

    const camera = new THREE.PerspectiveCamera(50, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
    camera.position.set(0, 3.5, 15);
    camera.rotation.x = -0.02;
    
    const renderer = new THREE.WebGLRenderer({ 
      canvas, 
      alpha: true, 
      antialias: true,
      powerPreference: "high-performance"
    });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(canvas.clientWidth, canvas.clientHeight);

    // Create art card textures
    const textureLoader = new THREE.TextureLoader();
    const artTextures = [
      textureLoader.load(document.getElementById('texture1')?.getAttribute('src') || ''),
      textureLoader.load(document.getElementById('texture2')?.getAttribute('src') || ''),
      textureLoader.load(document.getElementById('texture3')?.getAttribute('src') || '')
    ];

    // Create art cards with enhanced geometry and materials
    const cards: THREE.Mesh[] = [];
    const roundedRectShape = createRoundedRectShape(6, 6, 0.4);
    const extrudeSettings = {
      steps: 1,
      depth: 0.05,
      bevelEnabled: true,
      bevelThickness: 0.02,
      bevelSize: 0.02,
      bevelOffset: 0,
      bevelSegments: 3
    };
    const cardGeometry = new THREE.ExtrudeGeometry(roundedRectShape, extrudeSettings);
    
    // Adjust UV mapping with proper scaling
    const uvAttribute = cardGeometry.attributes.uv;
    const geometryPositions = cardGeometry.attributes.position;
    for (let i = 0; i < uvAttribute.count; i++) {
      const x = geometryPositions.getX(i);
      const y = geometryPositions.getY(i);
      uvAttribute.setXY(i, 
        (x + 3) / 6 * 0.9 + 0.05,          // Adjusted for new size
        1 - ((y + 3) / 6 * 0.9 + 0.05)     // Adjusted for new size
      );
    }

    // Update the card positions to include both start and end positions
    const cardPositions = [
      { 
        start: { x: 0, y: 2.0, z: 0.2, ry: 0 },
        end: { x: -7.0, y: 2.2, z: 0, ry: 0.25 }
      },
      { 
        start: { x: 0, y: 1.95, z: 0.1, ry: 0 },
        end: { x: 0, y: 1.9, z: 0, ry: -0.1 }
      },
      { 
        start: { x: 0, y: 1.9, z: 0, ry: 0 },
        end: { x: 7.0, y: 2.2, z: 0, ry: -0.25 }
      }
    ];
    
    artTextures.forEach((texture, index) => {
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;
      texture.flipY = false;
      
      // Front face material with texture
      const frontMaterial = new THREE.MeshPhysicalMaterial({
        map: texture,
        transparent: true,
        side: THREE.DoubleSide,
        metalness: 0.3,
        roughness: 0.4,
        emissive: 0x444444,
        emissiveIntensity: 0.18,
        clearcoat: 0.6,
        clearcoatRoughness: 0.2
      });

      // Edge material
      const edgeMaterial = new THREE.MeshPhysicalMaterial({
        color: 0x222222,
        metalness: 0.2,
        roughness: 0.9,
        side: THREE.DoubleSide
      });

      // Create materials array - first material is for front/back faces, second for edges
      const materials = [frontMaterial, edgeMaterial];
      const card = new THREE.Mesh(cardGeometry, materials);

      // Rest of the card setup...
      const pos = cardPositions[index];
      card.position.set(pos.start.x, pos.start.y, pos.start.z);
      
      // Reset to simple rotation
      card.rotation.set(-0.1, pos.start.ry, 0);
      
      card.geometry.center();
      cards.push(card);
      scene.add(card);
    });

    // Animation state
    let animationProgress = 0;
    const animationDuration = 1200;
    const startTime = Date.now();

    function easeOutQuint(x: number): number {
      return 1 - Math.pow(1 - x, 5);
    }

    function animate() {
      requestAnimationFrame(animate);
      
      const currentTime = Date.now();
      const elapsed = currentTime - startTime;
      animationProgress = Math.min(1, elapsed / animationDuration);
      const eased = easeOutQuint(animationProgress);

      const time = currentTime * 0.001;

      // Keep only the card animation code below
      cards.forEach((card, index) => {
        const pos = cardPositions[index];
        
        // Smoother stagger timing
        const staggerDelay = index * 0.1;  // Reduced from 0.15
        const staggeredProgress = Math.max(0, Math.min(1, 
          (animationProgress - staggerDelay) / (1 - staggerDelay)
        ));
        const staggeredEase = easeOutQuint(staggeredProgress);
        
        // Add subtle initial rise before fan-out
        const riseProgress = Math.min(1, animationProgress * 2);
        const initialRise = (1 - Math.cos(riseProgress * Math.PI)) * 0.1;
        
        // Adjust float and rotation amplitudes for larger cards
        const floatOffset = Math.sin(time * 0.8 + index * Math.PI * 0.5) * 0.25 * staggeredProgress;
        const sideFloat = Math.cos(time * 0.5 + index * Math.PI * 0.3) * 0.15 * staggeredProgress;
        
        // Larger bounce effect
        const bounce = Math.sin(staggeredProgress * Math.PI) * 0.25 * (1 - staggeredProgress);
        
        // Combine all movements with smooth blending
        card.position.x = pos.start.x + (pos.end.x - pos.start.x) * staggeredEase + sideFloat;
        card.position.y = pos.start.y + initialRise + 
                         (pos.end.y - pos.start.y) * staggeredEase + 
                         floatOffset + bounce;
        card.position.z = pos.start.z + (pos.end.z - pos.start.z) * staggeredEase;
        
        // Smoother rotation transitions
        const rotateX = Math.sin(time * 0.7 + index * 0.5) * 0.1 * staggeredProgress;
        const rotateY = Math.sin(time * 0.4 + index * Math.PI) * 0.15 * staggeredProgress;
        const rotateZ = Math.cos(time * 0.6 + index * 0.8) * 0.05 * staggeredProgress;
        
        card.rotation.x = -0.1 + rotateX;
        card.rotation.y = pos.start.ry + (pos.end.ry - pos.start.ry) * staggeredEase + rotateY;
        card.rotation.z = rotateZ;
        
        // Add wave effect to emissive intensity
        if (Array.isArray(card.material)) {
          const frontMaterial = card.material[0] as THREE.MeshPhysicalMaterial;
          frontMaterial.emissiveIntensity = 0.1 + Math.sin(time * 2 + index * Math.PI * 0.5) * 0.05;  // Increased variation
        }
      });

      renderer.render(scene, camera);
    }

    function handleResize() {
      const newWidth = canvas.clientWidth;
      const newHeight = canvas.clientHeight;
      
      camera.aspect = newWidth / newHeight;
      camera.updateProjectionMatrix();
      
      renderer.setSize(newWidth, newHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
    }

    window.addEventListener('resize', handleResize);
    animate();

    // Fine-tune fog
    scene.fog = new THREE.Fog(0x0a0f1c, 8, 35);
  });
</script> 